
//[1,2,3,4,1,1,2,3,1]
function mostX(a) {
    let r = 0;
    let s = [];
    a.forEach((e, i) => {
        if (!s[e]) s[e] = 0;
        s[e]++
    })
    //console.log(s);
    let max = findMax(s);
    //console.log(max);
    return s.indexOf(max);
}

function findMax(a) {
    let max = Number.MIN_VALUE;
    a.forEach(e => {
        if (max < e) {
            max = e;
        }
    })
    return max;
}

let inp = [1,2,3,4,1,1,2,3,1];
console.log(mostX(inp))


Мне понравилось такое определение - замыкание это паттерн приватизации переменной :) Но если объяснять своими словами, то: это когда фукнция имеет доступ к внешнему лексическому окружению которое было доступно ранее во внешнем контексте. И может предоставлять к нему доступ ограниченный, да. Вообще как это можно кратко объяснить? Надо сперва сказать что есть лексические окружения которые хранят переменные в текущем контексте. Вызов функции например, создаёют новое лексическое окружение которое имеет ссылку на внешнее. Но доступно оно обычно только при вызове функции, то есть коду который находитя в данном контексте. Но можно вернуть например функцию имеющую доступ к внешнему контексту - и через неё получить доступ к этому контексту коду, который не находится в нём, то есть некоторым образом "замкнуть" это лексическое окружение. Как то так :)
var - legacy способ объявления переменных. Основное отличие - всплывание (hoisting) переменных объявленных через var. То есть они становятся видны в самом начале выполнения блока кода в котором объявлены.
spread-оператор это так сказать "деструктуризация" итерируемых объектов (напр. массивов) - раскрывает объект на отдельные элементы. Используют для "раскрытия" объекта и его последующего дополнения или для передачи массива как списка параметров в функцию или включения содержания одного массива в другой.
Promise это объект для создания асинхронного кода. Позволяет асинхронно (как микрозадачу) выполнять некоторый код и обрабатывать его результат посредством передачи колбэков в методы then/catch/finally. И в догонку добавлю что промисы отличаются от Observable (от rx потоков) тем что они так сказать одноразовые.
значения свойства position - fixed как и absolute вырывает элемент из потока. Но fixed позиционируется относительно окна, тогда как при значении absolute позиционирования элемента происходит относительно ближайшего позиционированно(не по дефолту) родительского элемента.
SPA - подход в создание веб-приложения при котором избегается перезагрузка страницы. То есть всё взаимодействие и переходы реализуются манипуляциями с DOM или CSSOM и асинхронной подгрузкой данных с сервера.
MPA - более старый подход - обычные отдельные страницы. Полностью перезагружается страница.
Следовательно в MPA приложении больше нагрузка на веб-сервер, более "рваный" UX, но ничего не стоит организовать статичные url, тогда как в SPA для этого нужно приложить усилия. К тому же в SPA нужно детальней продумать более сложное взаимодействие с бекэндом + сложности в реализации упомянутых манипуляций с DOM итп.
Есть public, protected, private. Public - по дефолту (если не указан) - доступен везде. Protected - доступен только в подклассах. Private - самый ограничивающий - доступ только самому классу.
нет. Это первое что я попытался сделать при изучении и сразу же напоролся :D
Нельзя делать множество реализаций конструктора, тем не менее можно объявлять несколько сигнатур типов для него, но реализация должна быть совместима со всеми.
Если подумать, то это логично - ts транспилется в js в котором перегрузки конструктора не имеют особого смысла и что важнее, является его надмножеством. (Хотя мог быть и другой путь)
Enums это тип - перечисление. Могут быть как с числовыми значениями так и со строковыми. Можно сделать и со смешанными типами и с вычиляемыми.
| - используется для создания union типов и для unit типа
Директивы это декораторы (классы для добавления дополнительного поведения, для привязки метаданных) - в ангуляре - добавляют поведение элементам dom. Стандартные: аттрибутивные: ngStyle, ngModel, ngClass, структурные: ngIf, ngFor
Использовать декоратор @ViewChild совместно со ссылкой на элемент (#elemntRef)
Pipe это класс декорированный @Pipe. Используются в биндингах шаблона для трансформации выводимых значений.
Использоваля KeyValue пайп для итерации объекта.
Писал свои: https://github.com/anokata/comleave/blob/master/front/app/worktype.pipe.ts
